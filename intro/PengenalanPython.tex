\documentclass[a4paper,11pt]{extarticle}
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2cm,lmargin=2cm,rmargin=2cm}

\usepackage{fontspec}
\setmonofont{FreeMono}

\setlength{\parindent}{0cm}
\setlength{\parskip}{0.5em}

\usepackage{textcomp}

\usepackage{hyperref}
\usepackage{url}
\usepackage{xcolor}

\usepackage{minted}
\newminted{pycon}{breaklines,fontsize=\small}
\newminted{python}{breaklines,fontsize=\small}
\newminted{text}{breaklines,fontsize=\small}

\definecolor{mintedbg}{rgb}{0.95,0.95,0.95}
\usepackage{mdframed}

\BeforeBeginEnvironment{minted}{\begin{mdframed}[backgroundcolor=mintedbg]}
\AfterEndEnvironment{minted}{\end{mdframed}}

\title{
MI3103 \\
Praktikum Antar Muka Komputer\\
Pengantar Pemrograman Python}
\author{Fadjar Fathurrahman}
\date{2018}

\begin{document}
\maketitle

\section{Tujuan}
\begin{itemize}
\item Dapat membuat dan mengeksekusi program Python sederhana
\end{itemize}

\section{Perangkat lunak yang diperlukan}
\begin{itemize}
\item Linux OS
\item Distribusi Anaconda untuk Python 3
\item Browser
\item Editor teks seperti \textsf{gedit}, \textsf{VSCode}, \textsf{Atom}
\end{itemize}

\section{Pendahuluan}

\url{http://www.scipy-lectures.org/language/first_steps.html}

\section{Mengenal interpreter Python (konsol Python)}

Terdapat banyak pilihan untuk berinteraksi dengan interpreter Python:
\begin{itemize}
\item Terminal default Python, dapat dijalankan dengan mengetikkan
\texttt{python} pada terminal.
\item IPython, merupakan interpreter Python dengan berbagai fitur tambahan
seperti \textit{tab-completion} dan \textit{syntax highlighting}.
IPython 
\item Jupyter qtconsole
\item Jupyter notebook
\end{itemize}

Tampilan awal konsol Python default:
\begin{textcode}
Python 3.6.6 |Anaconda custom (64-bit)| (default, Jun 28 2018, 17:14:51) 
[GCC 7.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
\end{textcode}

Tampilan awal IPython
\begin{textcode}
Python 3.6.6 |Anaconda custom (64-bit)| (default, Jun 28 2018, 17:14:51) 
Type 'copyright', 'credits' or 'license' for more information
IPython 6.4.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]:
\end{textcode}

Aritmatika
\begin{pyconcode}
>>> 2 + 3
5
>>> 2 / 3
0.6666666666666666
\end{pyconcode}

Variabel
\begin{pyconcode}
>>> a = 3
>>> b = 4.1
>>> a*b
12.299999999999999
>>> a - b
-1.0999999999999996
>>> a/b
0.7317073170731708
\end{pyconcode}

\subsection{Tipe data}

Integer variables::
\begin{pyconcode}
>>> 1 + 1
2
>>> a = 4
\end{pyconcode}

floats ::
\begin{pyconcode}
>>> c = 2.1
\end{pyconcode}

Bilangan kompleks
\begin{pyconcode}
>>> a = 1.5 + 0.5j
>>> a.real
1.5
>>> a.imag
0.5
\end{pyconcode}

and booleans::
\begin{pyconcode}
>>> 3 > 4
False
>>> test = (3 > 4)
>>> test
False
>>> type(test)
<type 'bool'>
\end{pyconcode}


A Python shell can therefore replace your pocket calculator, with the
basic arithmetic operations +, -, *, /, \texttt{\%} (modulo)
natively implemented::
\begin{pyconcode}
>>> 7 * 3.0
21.0
>>> 2**10
1024
>>> 8%3
2
\end{pyconcode}

Scalar types: int, float, complex, bool::
\begin{pyconcode}
>>> type(1)
<type 'int'>
>>> type(1.)
<type 'float'>
>>> type(1. + 0j )
<type 'complex'>

>>> a = 3
>>> type(a)
<type 'int'>
\end{pyconcode}


* Type conversion::
\begin{pyconcode}
>>> float(1)
1.0
\end{pyconcode}

\subsection{Containers}


Python provides many efficient types of containers, in which collections of
objects can be stored.

\subsubsection{Lists}

A list is an ordered collection of objects, that may have different
types. For example ::
\begin{pyconcode}
>>> l = [1, 2, 3, 4, 5]
>>> type(l)
<type 'list'>
\end{pyconcode}

Indexing: accessing individual objects contained in the list::
\begin{pyconcode}
>>> l[2]
3
\end{pyconcode}

Counting from the end with negative indices::
\begin{pyconcode}
>>> l[-1]
5
>>> l[-2]
4
\end{pyconcode}

warning

Indexing starts at 0** (as in C), not at 1 (as in Fortran or Matlab)!

Slicing: obtaining sublists of regularly-spaced elements
\begin{pyconcode}
>>> l
[1, 2, 3, 4, 5]
>>> l[2:4]
[3, 4]
\end{pyconcode}

Warning

Note that l[start:stop] contains the elements with indices i
such as  \texttt{start<= i < stop} (i ranging from start to
stop-1). Therefore, l[start:stop] has (stop-start) elements.

Slicing syntax: l[start:stop:stride]

All slicing parameters are optional::
\begin{pyconcode}
>> l[3:]
4, 5]
>> l[:3]
1, 2, 3]
>> l[::2]
1, 3, 5]
\end{pyconcode}

Lists are mutable objects and can be modified::
\begin{pyconcode}
>>> l[0] = 28
>>> l
[28, 2, 3, 4, 5]
>>> l[2:4] = [3, 8] 
>>> l
[28, 2, 3, 8, 5]
\end{pyconcode}

Note;

The elements of a list may have different types::
\begin{pyconcode}
>>> l = [3, 2, 'hello']
>>> l
[3, 2, 'hello']
>>> l[1], l[2]
(2, 'hello')
\end{pyconcode}

As the elements of a list can be of any type and size, accessing the
i th element of a list has a complexity O(i). For collections of
numerical data that all have the same type, it is **more efficient** to use
the **array** type provided by the **Numpy** module, which is a sequence
of regularly-spaced chunks of memory containing fixed-sized data istems.
With Numpy arrays, accessing the i`th` element has a complexity of O(1)
because the elements are regularly spaced in memory.

Add and remove elements::
\begin{pyconcode}
>>> l = [1, 2, 3, 4, 5]
>>> l.append(6)
>>> l
[1, 2, 3, 4, 5, 6]
>>> l.pop()
6
>>> l
[1, 2, 3, 4, 5]
>>> l.extend([6, 7]) # extend l, in-place
>>> l
[1, 2, 3, 4, 5, 6, 7]
>>> l = l[:-2]
>>> l
[1, 2, 3, 4, 5]
\end{pyconcode}

Reverse l
\begin{pyconcode}
>>> r = l[::-1]
>>> r
[5, 4, 3, 2, 1]
\end{pyconcode}

Concatenate and repeat lists:: 
\begin{pyconcode}
>>> r + l
[5, 4, 3, 2, 1, 1, 2, 3, 4, 5]
>>> 2 * r
[5, 4, 3, 2, 1, 5, 4, 3, 2, 1]
\end{pyconcode}

Sort r (in-place)::
\begin{pyconcode}
>>> r.sort()
>>> r
[1, 2, 3, 4, 5]
\end{pyconcode}

Note:: **Methods and Object-Oriented Programming**

The notation r.method() (r.sort(), r.append(3), l.pop()) is our
first example of object-oriented programming (OOP). Being a list, the
object `r` owns the *method* `function` that is called using the notation
**.**. No further knowledge of OOP than understanding the notation **.** is
necessary for going through this tutorial.  



\subsection{Strings}

Different string syntaxes (simple, double or triple quotes)::
\begin{pyconcode}
s = 'Hello, how are you?'
s = "Hi, what's up"
s = '''Hello, 
       how are you'''
s = """Hi,
   what's up?'''
\end{pyconcode}

The newline character is \verb|\n|, and the tab characted is
\verb|\t|.

Strings are collections as lists. Hence they can be indexed and sliced,
using the same syntax and rules.

Indexing::
\begin{pyconcode}
>>> a = "hello"
>>> a[0]
'h'
>>> a[1]
'e'
>>> a[-1]
'o'
\end{pyconcode}

(Remember that Negative indices correspond to counting from the right
end.)

Slicing

\begin{pyconcode}
>>> a = "hello, world!"
>>> a[3:6] # 3rd to 6th (excluded) elements: elements 3, 4, 5
'lo,'
>>> a[2:10:2] # Syntax: a[start:stop:step]
'lo o'
>>> a[::3] # every three characters, from beginning to end 
'hl r!'
\end{pyconcode}

A string is an **immutable object** and it is not possible to modify its
characters. One may however create new strings from an original one.

Strings have many useful methods, such as a.replace as seen above.
Remember the a. object-oriented notation and use tab completion or
help(str) to search for new methods.


String substitution
\begin{pyconcode}
>>> 'An integer: %i; a float: %f; another string: %s' % (1, 0.1, 'string')
    'An integer: 1; a float: 0.100000; another string: string'
>>> i = 102
>>> filename = 'processing_of_dataset_%03d.txt'%i
>>> filename
'processing_of_dataset_102.txt'
\end{pyconcode}

\subsection{Dictionary/Kamus}

Tipe data kamus adalah tabel yang yang memetakan kunci ke suatu nilai.

is basically a hash table that **maps keys to values**. It
is therefore an **unordered** container::

\begin{pyconcode}
>>> tel = {'emmanuelle': 5752, 'sebastian': 5578}
>>> tel['francis'] = 5915 
>>> tel
{'sebastian': 5578, 'francis': 5915, 'emmanuelle': 5752}
>>> tel['sebastian']
5578
>>> tel.keys()
['sebastian', 'francis', 'emmanuelle']
>>> tel.values()
[5578, 5915, 5752]
>>> 'francis' in tel
True
\end{pyconcode}

Suatu kamus dapat memiliki kunci dan nilai yang memiliki tipe berbeda
\begin{pyconcode}
>>> d = {'a':1, 'b':2, 3:'hello'}
>>> d
{'a': 1, 3: 'hello', 'b': 2}
\end{pyconcode}

\subsection{Tupel}

Tuples are basically immutable lists. The elements of a tuple are written
between brackets, or just separated by commas
\begin{pyconcode}
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> u = (0, 2)
\end{pyconcode}

\subsection{Set/Himpunan}

Sets (himpunan): non ordered, unique items
\begin{pyconcode}
>>> s = set(('a', 'b', 'c', 'a'))
>>> s
set(['a', 'c', 'b'])
>>> s.difference(('a', 'b'))
set(['c'])
\end{pyconcode}

Complex: cmath module


\subsection{Control Flow}

Controls the order in which the code is executed.

if/elif/else
------------

.. sourcecode:: ipython
  
    In [1]: if 2**2 == 4:
       ...:     print('Obvious!')
       ...: 
    Obvious!


**Blocks are delimited by indentation**

Type the following lines in your Python interpreter, and be careful to
**respect the indentation depth**. The Ipython shell automatically
increases the indentation depth after a column ``:`` sign; to
decrease the indentation depth, go four spaces to the left with the
Backspace key. Press the Enter key twice to leave the logical block.

.. sourcecode:: ipython

    In [2]: a = 10
    
    In [3]: if a == 1:
       ...:     print(1)
       ...: elif a == 2:
       ...:     print(2)
       ...: else:
       ...:     print('A lot')
       ...: 
    A lot

Indentation is compulsory in scripts as well. As an exercise, re-type the
previous lines with the same indentation in a script ``condition.py``, and
execute the script with ``run condition.py`` in Ipython.

for/range
----------

Iterating with an index:

.. sourcecode:: ipython

    In [4]: for i in range(4):
       ...:     print(i)
       ...: 
    0
    1
    2
    3

But most often, it is more readable to iterate over values:

.. sourcecode:: ipython

    In [5]: for word in ('cool', 'powerful', 'readable'):
       ...:     print('Python is %s' % word)
       ...: 
    Python is cool
    Python is powerful
    Python is readable


while/break/continue
---------------------

Typical C-style while loop (Mandelbrot problem):

.. sourcecode:: ipython

    In [6]: z = 1 + 1j

    In [7]: while abs(z) < 100:
       ...:     z = z**2 + 1
       ...:     

    In [8]: z
    Out[8]: (-134+352j)

**More advanced features**

``break`` out of enclosing for/while loop:

.. sourcecode:: ipython

    In [9]: z = 1 + 1j

    In [10]: while abs(z) < 100:
       ....:     if z.imag == 0:
       ....:         break
       ....:     z = z**2 + 1
       ....:     
       ....:     


``continue`` the next iteration of a loop.::

    >>> a = [1, 0, 2, 4]
    >>> for element in a:
    ...     if element == 0:
    ...         continue
    ...     print 1. / element
    ...     
    1.0
    0.5
    0.25



Conditional Expressions
-----------------------

* `if object`

  Evaluates to True:
    * any non-zero value
    * any sequence with a length > 0

  Evaluates to False:
    * any zero value
    * any empty sequence

* `a == b`

  Tests equality, with logics:

  .. sourcecode:: ipython

    In [19]: 1 == 1.
    Out[19]: True

* `a is b`

  Tests identity: both objects are the same

  .. sourcecode:: ipython

    In [20]: 1 is 1.
    Out[20]: False

    In [21]: a = 1

    In [22]: b = 1

    In [23]: a is b
    Out[23]: True

* `a in b`

  For any collection `b`: `b` contains `a` ::

    >>> b = [1, 2, 3]
    >>> 2 in b
    True
    >>> 5 in b
    False


  If `b` is a dictionary, this tests that `a` is a key of `b`.

Advanced iteration


Iterate over any *sequence*


* You can iterate over any sequence (string, list, dictionary, file, ...)

  .. sourcecode:: ipython

    In [11]: vowels = 'aeiouy'

    In [12]: for i in 'powerful':
       ....:     if i in vowels:
       ....:         print(i),
       ....:         
       ....:         
    o e u

::

    >>> message = "Hello how are you?"
    >>> message.split() # returns a list
    ['Hello', 'how', 'are', 'you?']
    >>> for word in message.split():
    ...     print word
    ...     
    Hello
    how
    are
    you?

Few languages (in particular, languages for scienfic computing) allow to
loop over anything but integers/indices. With Python it is possible to
loop exactly over the objects of interest without bothering with indices
you often don't care about.
 
warning:: Not safe to modify the sequence you are iterating over.

Keeping track of enumeration number

Common task is to iterate over a sequence while keeping track of the
item number.

* Could use while loop with a counter as above. Or a for loop:

    In [13]: for i in range(0, len(words)):
       ....:     print(i, words[i])
       ....:     
       ....:     
    0 cool
    1 powerful
    2 readable

But Python provides enumerate for this
\begin{pycodecode}
>>> words = ('cool', 'powerful', 'readable')
>>> for index, item in enumerate(words):
...     print index, item
...     
0 cool
1 powerful
2 readable
\end{pyconcode}


Looping over a dictionary

Use \texttt{items()}
\begin{pyconcode}
>>> d = {"a" : 1, "b" : 1.2, "c" : 1j}
>>> for key, val in d.items():
        print('Key: %s has value: %s' % (key, val)
Key: a has value: 1
Key: c has value: 1j
Key: b has value: 1.2
\end{pycode}

List Comprehensions
\begin{pyconcode}
In [16]: [i**2 for i in range(4)]
Out[16]: [0, 1, 4, 9]
\end{pyconcode}






\end{document}