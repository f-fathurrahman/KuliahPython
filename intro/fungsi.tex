\section{Fungsi (subsprogram)}

Sintaks dasar:
\begin{pyconcode}
>>> def test():
...     print("in test function")
...
>>> test()
in test function
\end{pyconcode}

\textbf{Ingat bahwa indentasi signifikan pada Python}

Fungsi dapat mengembalikan nilai
\begin{pyconcode}
>>> def disk_area(radius):
...     return 3.14 * radius * radius
...
>>> disk_area(1.5)
>>> 7.0649999999999995
\end{pyconcode}

Secara default, fungsi mengembalikan \texttt{None}.

\subsection{Parameter fungsi}

Parameter fungsi pada Python dapat berupa parameter wajib yang sesuai
dengan posisinya pada definisi fungsi.

\begin{pyconcode}
>>> def double_it(x):
...     return x*2
... 
>>> double_it(3)
6
>>> double_it(3.2)
6.4
>>> double_it()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: double_it() missing 1 required positional argument: 'x'
>>> double_it(3,1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: double_it() takes 1 positional argument but 2 were given
\end{pyconcode}

Argumen fungsi pada Python juga dapat bersifat
opsional, dengan menggunakan kata kunci atau nama argumen.
Dengan menggunakan argument kata kunci, kita dapat memberikan nilai
default pada fungsi.
\begin{pythoncode}
def double_it(x=2):
    return x * 2
double_it()
double_it(3)
\end{pythoncode}


\subsection{Modifikasi parameter fungsi}

Sebagian besar bahasa pemrograman seperti C dan Java membedakan antara
\textit{pass-by-value} dan \textit{pass-by-reference}.
Pada fungsi dengan \textit{pass-by-value}, argumen pada fungsi tidak dapat
diubah karena hanya nilainya saja yang diberikan, sedangkan untuk
\textit{pass-by-reference} argumen pada fungsi dapat diubah nilainya.
Pada Python, tidak ada aturan khusus mengenai apakah suatu argumen pada suatu
fungsi bersifat \textit{pass-by-value} atau \textit{pass-by-reference}.

%Parameter pada suatu fungsi adalah referensi ke objek yang diberikan
%dengan nilai. Ketika suatu variabel diberikan ke suatu fungsi, Python
%akan memberikan referensi ke objek yang dirujuk oleh variabel yaitu
%suatu nilai, bukan variabel itu sendiri.

Jika nilai yang diberikan pada suatu fungsi bersifat \textit{immutable}, fungsi
tidak akan memodifikasi variabel tersebut. Jika nilai tersebut bersifat
\textit{mutable}, maka fungsi dapat mengubah nilai tersebut.

Tipe data sepertin \texttt{int}, \texttt{float},
\texttt{bool}, \texttt{str}, \texttt{tuple} bersifat \textit{immutable}.
Sedangkan \texttt{list}, \texttt{set}, \texttt{dict}
bersifat \textit{mutable}. 

\begin{pythoncode}
def try_to_modify(x, y, z):
    x = 23
    y.append(42)
    z = [99] # ubah z
    print(x)
    print(y)
    print(z)

a = 77    # variabel immutable
b = [99]  # variabel mutable
c = [28]
try_to_modify(a, b, c)
print(a)
print(b)
print(c)
\end{pythoncode}

Fungsi memiliki lingkup variabel sendiri. Dalam kode sebelumnya,
variabel \texttt{x} hanya ada di dalam fungsi \texttt{try\_to\_modify}.


\subsection{Variabel global}

Variable yang dideklarasikan di luar sebuh fungsi dapat direferensi (digunakan)
di dalam sebuah fungsi.

\begin{pythoncode}
x = 5
def addx(y):
    return x + y
z = addx(10)
print(z)
\end{pythoncode}

Akan tetapi variable global tersebut tidak dapat dimodifikasi di dalam sebuah
fungsi, kecuali jika dideklarasikan sebagai \texttt{global} di dalam fungsi
tersebut.

Bandingkan antara keluaran kode berikut:
\begin{pythoncode}
x = 5
def setx(y):
    x = y
    print("x is %d" % x)
setx(10)
print(x)
\end{pythoncode}
%
dengan kode berikut ini.
%
\begin{pythoncode}
x = 5
def setx(y):
    global x
    x = y
    print("x is %d" % x)
setx(10)
print(x)
\end{pythoncode}


\subsection{Variable number of parameters}

Dua bentuk khusus dari parameter fungsi:
\begin{itemize}
\item \verb|*args|: any number of positional arguments packed into a tuple
\item \verb|**kwargs|: any number of keyword arguments packed into a dictionary
\end{itemize}

Contoh:

\begin{pythoncode}
def variable_args(*args, **kwargs):
    print("args is", args)
    print("kwargs is", kwargs)
variable_args("one", "two", x=1, y=2, z=3)
\end{pythoncode}


\subsection{Functions are objects}

Functions are first-class objects, which means they can be:
\begin{itemize}
\item assigned to a variable
\item an item in a list (or any collection)
\item passed as an argument to another function.
\end{itemize}

\begin{pythoncode}
def variable_args(*args, **kwargs):
    print("args is", args)
    print("kwargs is", kwargs)
va = variable_args
va('three', x=1, y=2)
\end{pythoncode}

\subsection{Metode}

Metode adalah fungsi yang dapat diakses dari suatu objek.
Kita telah menggunakan metode pada contoh-contoh sebelumnya.
Misalnya pada objek string:
\begin{pyconcode}
>>> a = "My name is Jojo"
>>> a.upper()
'MY NAME IS JOJO'
>>> a.replace("Jojo", "Koko")
'My name is Koko
\end{pyconcode}
Metode atau fungsi \texttt{upper()} dan \texttt{replace()} diakses melalui objek
\texttt{a} yang merupakan sebuah string.

